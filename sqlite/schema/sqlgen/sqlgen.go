// Copyright (c) 2025 AUTHORS All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// sqlgen is a tool to generate SQL schema from Go struct types.
//
// It generates CREATE TABLE statements based on struct tags and follows
// the schema conventions for the codename database.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/types"
	"log"
	"os"
	"reflect"
	"strings"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
	"tailscale.com/util/codegen"
)

var (
	flagTypes         = flag.String("type", "", "comma-separated list of types; required")
	flagBuildTags     = flag.String("tags", "", "compiler build tags to apply")
	flagSchemaName    = flag.String("schema-name", "main", "schema name for schema_version table")
	flagSchemaVersion = flag.Int("schema-version", 1, "schema version number")
	flagOutput        = flag.String("output", "schema.sql", "output file name")
)

func main() {
	log.SetFlags(0)
	log.SetPrefix("sqlgen: ")
	flag.Parse()
	if len(*flagTypes) == 0 {
		flag.Usage()
		os.Exit(2)
	}
	typeNames := strings.Split(*flagTypes, ",")

	pkg, namedTypes, err := codegen.LoadTypes(*flagBuildTags, ".")
	if err != nil {
		log.Fatal(err)
	}

	schemaBuffer := new(bytes.Buffer)
	goCodeBuffer := new(bytes.Buffer)

	// Write go code comment
	fmt.Fprintf(goCodeBuffer, "// Code generated by sqlgen. DO NOT EDIT.\n\n")
	fmt.Fprintf(goCodeBuffer, "package %s\n\n", pkg.Name)

	// Write schema conventions comment
	writeSchemaConventions(schemaBuffer)

	// Write schema_version and safe_ids tables
	writeBoilerplateTables(schemaBuffer, *flagSchemaName, *flagSchemaVersion)

	// Process each type
	for i, typeName := range typeNames {
		typ, ok := namedTypes[typeName].(*types.Named)
		if !ok {
			log.Fatalf("could not find type %s", typeName)
		}
		tableName := toSnakeCase(typeName) + "s"

		// Special case for types ending in "y" - change to "ies"
		if strings.HasSuffix(strings.ToLower(typeName), "history") {
			tableName = toSnakeCase(typeName)
		} else if strings.HasSuffix(strings.ToLower(typeName), "y") && !strings.HasSuffix(strings.ToLower(typeName), "ey") {
			tableName = toSnakeCase(typeName[:len(typeName)-1]) + "ies"
		}
		if err := generateTable(schemaBuffer, pkg, typ, tableName); err != nil {
			log.Fatalf("failed to generate table for %s: %v", typeName, err)
		}
		// Add newline between tables, but not after the last one
		if i < len(typeNames)-1 {
			fmt.Fprintf(schemaBuffer, "\n")
		}
		if tp := typ.TypeParams(); tp != nil && tp.Len() > 0 {
			fmt.Fprintf(goCodeBuffer, "func (%s[", typeName)
			for i := 0; i < tp.Len(); i++ {
				tp := tp.At(i)
				if i > 0 {
					fmt.Fprintf(goCodeBuffer, ", ")
				}
				fmt.Fprintf(goCodeBuffer, "%s", tp.String())
			}
			fmt.Fprintf(goCodeBuffer, "]) TableName() string { return %q }\n", tableName)
		} else {
			fmt.Fprintf(goCodeBuffer, "func (%s) TableName() string { return %q }\n", typeName, tableName)
		}
	}

	// Write to file
	if err := os.WriteFile(*flagOutput, schemaBuffer.Bytes(), 0644); err != nil {
		log.Fatal(err)
	}
	if err := writeFormatted(goCodeBuffer.Bytes(), pkg.Name+"_tables.go"); err != nil {
		log.Fatal(err)
	}
}

func writeFormatted(code []byte, path string) error {
	out, fmterr := imports.Process(path, code, &imports.Options{
		Comments:   true,
		TabIndent:  true,
		TabWidth:   8,
		FormatOnly: true, // fancy gofmt only
	})
	if fmterr != nil {
		out = code
	}
	return os.WriteFile(path, out, 0644)
}

func writeSchemaConventions(buf *bytes.Buffer) {
	fmt.Fprintln(buf, `-- Autogenerated from types.go by sqlgen; DO NOT EDIT.`)
	fmt.Fprintln(buf)
}

func writeBoilerplateTables(buf *bytes.Buffer, schemaName string, schemaVersion int) {
	fmt.Fprintf(buf, `CREATE TABLE schema_version (
  Name TEXT PRIMARY KEY,
  Version INTEGER NOT NULL
) STRICT;
INSERT INTO schema_version (Name, Version) VALUES ('%s', %d);

CREATE TABLE safe_ids (
  ID INTEGER PRIMARY KEY,
  Type TEXT NOT NULL
) STRICT;

`, schemaName, schemaVersion)
}

type uniqueColumn struct {
	columnName  string
	isOmitEmpty bool
}

type fieldResult struct {
	columns       []string
	foreignKeys   []string
	uniqueColumns []uniqueColumn
	indexColumns  []string
}

func processStructFields(structType *types.Struct, jsonPrefix string) fieldResult {
	var result fieldResult

	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)
		fieldType := field.Type()
		tag := reflect.StructTag(structType.Tag(i))
		sqlTag := tag.Get("sql")

		if sqlTag == "" {
			continue
		}

		// Handle embedded types with ,inline tag
		if field.Embedded() && sqlTag == ",inline" {
			// Get the underlying struct type of the embedded field
			embeddedType := fieldType
			// Handle pointer to struct
			if ptr, ok := embeddedType.(*types.Pointer); ok {
				embeddedType = ptr.Elem()
			}
			// Handle named types
			if named, ok := embeddedType.(*types.Named); ok {
				embeddedType = named.Underlying()
			}
			if embeddedStruct, ok := embeddedType.(*types.Struct); ok {
				// Recursively process embedded struct fields
				embedded := processStructFields(embeddedStruct, jsonPrefix)
				result.columns = append(result.columns, embedded.columns...)
				result.foreignKeys = append(result.foreignKeys, embedded.foreignKeys...)
				result.uniqueColumns = append(result.uniqueColumns, embedded.uniqueColumns...)
				result.indexColumns = append(result.indexColumns, embedded.indexColumns...)
			}
			continue
		}

		// Parse sql tags: first part is column name override, rest are options
		// If a custom name is provided, stored is assumed by default
		tagParts := strings.Split(sqlTag, ",")
		columnName := field.Name()
		hasCustomName := tagParts[0] != ""
		if hasCustomName {
			columnName = tagParts[0]
		}

		isStored := hasCustomName // stored is implied when custom name is provided
		isVirtual := false
		isUnique := false
		isIndex := false
		isOmitempty := false
		var foreignKey string

		for _, part := range tagParts[1:] {
			part = strings.TrimSpace(part)
			switch {
			case part == "stored":
				isStored = true
			case part == "virtual":
				isVirtual = true
			case part == "unique":
				isUnique = true
			case part == "index":
				isIndex = true
			case part == "omitempty":
				isOmitempty = true
			case strings.HasPrefix(part, "fk:"):
				foreignKey = strings.TrimPrefix(part, "fk:")
			}
		}

		if !isStored && !isVirtual {
			continue // Skip fields without stored/virtual tags
		}

		// Determine SQL type
		sqlType := getSQLType(fieldType)
		jsonPath := jsonPrefix + field.Name()

		// Build column definition
		generationType := "STORED"
		if isVirtual {
			generationType = "VIRTUAL"
		}

		// Determine if column should be nullable
		notNull := " NOT NULL"
		if isOmitempty {
			notNull = ""
		}

		columnDef := fmt.Sprintf("  %s %s%s GENERATED ALWAYS AS ", columnName, sqlType, notNull)

		// Handle time.Time fields specially
		if sqlType == "INTEGER" && isTimeType(fieldType) {
			columnDef += fmt.Sprintf("(strftime('%%s', JSONObj->>'$.%s')) %s", jsonPath, generationType)
		} else {
			columnDef += fmt.Sprintf("(JSONObj->>'$.%s') %s", jsonPath, generationType)
		}

		if isUnique {
			result.uniqueColumns = append(result.uniqueColumns, uniqueColumn{columnName, isOmitempty})
		}

		if isIndex {
			result.indexColumns = append(result.indexColumns, columnName)
		}

		result.columns = append(result.columns, columnDef)

		// Handle foreign keys
		if foreignKey != "" {
			parts := strings.Split(foreignKey, ".")
			if len(parts) == 2 {
				refTable := toSnakeCase(parts[0]) + "s"
				// Handle special pluralization
				if strings.HasSuffix(strings.ToLower(parts[0]), "y") && !strings.HasSuffix(strings.ToLower(parts[0]), "ey") {
					refTable = toSnakeCase(parts[0][:len(parts[0])-1]) + "ies"
				}
				refColumn := parts[1]
				fk := fmt.Sprintf("  FOREIGN KEY (%s) REFERENCES %s(%s) ON DELETE CASCADE",
					columnName, refTable, refColumn)
				result.foreignKeys = append(result.foreignKeys, fk)
			}
		}
	}

	return result
}

func generateTable(buf *bytes.Buffer, pkg *packages.Package, typ *types.Named, tableName string) error {
	structType, ok := typ.Underlying().(*types.Struct)
	if !ok {
		return fmt.Errorf("%s is not a struct type", typ.Obj().Name())
	}

	typeName := typ.Obj().Name()

	// Extract custom SQL statements from comments
	customSQL := extractSQLComments(pkg, typeName)

	fmt.Fprintf(buf, "CREATE TABLE %s (\n", tableName)

	// Always add ID and JSONObj columns first
	columns := []string{
		"  ID INTEGER PRIMARY KEY",
		"  JSONObj BLOB NOT NULL",
	}

	// Process struct fields recursively
	result := processStructFields(structType, "")
	columns = append(columns, result.columns...)
	foreignKeys := result.foreignKeys
	uniqueColumns := result.uniqueColumns
	indexColumns := result.indexColumns

	// Write all columns
	for i, col := range columns {
		if i < len(columns)-1 || len(foreignKeys) > 0 {
			fmt.Fprintf(buf, "%s,\n", col)
		} else {
			fmt.Fprintf(buf, "%s\n", col)
		}
	}

	// Write foreign keys
	for i, fk := range foreignKeys {
		if i < len(foreignKeys)-1 {
			fmt.Fprintf(buf, "%s,\n", fk)
		} else {
			fmt.Fprintf(buf, "%s\n", fk)
		}
	}

	fmt.Fprintf(buf, ") STRICT;\n")

	// Write unique constraints as separate CREATE UNIQUE INDEX statements
	for _, col := range uniqueColumns {
		// Use snake_case for column names in index names
		indexName := fmt.Sprintf("%s_%s", tableName, toSnakeCase(col.columnName))
		if col.isOmitEmpty {
			fmt.Fprintf(buf, "CREATE UNIQUE INDEX %s ON %s (%s) WHERE %s IS NOT NULL;\n", indexName, tableName, col.columnName, col.columnName)
		} else {
			fmt.Fprintf(buf, "CREATE UNIQUE INDEX %s ON %s (%s);\n", indexName, tableName, col.columnName)
		}
	}

	// Write regular indexes
	for _, col := range indexColumns {
		// Use snake_case for column names in index names
		indexName := fmt.Sprintf("%s_%s", tableName, toSnakeCase(col))
		fmt.Fprintf(buf, "CREATE INDEX %s ON %s (%s);\n", indexName, tableName, col)
	}

	// Write custom SQL statements from comments
	for _, sql := range customSQL {
		fmt.Fprintf(buf, "%s\n", sql)
	}

	return nil
}

func getSQLType(t types.Type) string {
	// Check if it's a time.Time first
	if isTimeType(t) {
		return "INTEGER"
	}

	// Check for ID types
	typeStr := t.String()
	if strings.Contains(typeStr, "ID") {
		return "INTEGER"
	}

	switch t := t.Underlying().(type) {
	case *types.Basic:
		switch t.Kind() {
		case types.String:
			return "TEXT"
		case types.Int, types.Int64, types.Int32:
			return "INTEGER"
		case types.Bool:
			return "INTEGER"
		default:
			return "TEXT"
		}
	case *types.Slice:
		return "TEXT" // JSON array
	default:
		return "TEXT"
	}
}

func isTimeType(t types.Type) bool {
	return strings.Contains(t.String(), "time.Time")
}

var directMappings = []struct {
	From, To string
}{
	{"URL", "url"},
	{"IPv6", "ipv6"},
	{"IPv4", "ipv4"},
	{"IP", "ip"},
	{"ID", "id"},
	{"VM", "vm"},
	{"SSH", "ssh"},
}

func toSnakeCase(s string) string {
	for _, v := range directMappings {
		if pre, suf, ok := strings.Cut(s, v.From); ok {
			var sb strings.Builder
			if len(pre) > 0 {
				sb.WriteString(toSnakeCase(pre))
				sb.WriteString("_")
			}
			sb.WriteString(v.To)
			if len(suf) > 0 {
				sb.WriteString("_")
				sb.WriteString(toSnakeCase(suf))
			}
			return sb.String()
		}
	}

	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		// Convert to lowercase
		if r >= 'A' && r <= 'Z' {
			result.WriteRune(r + 32) // Convert to lowercase
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

// extractSQLComments finds SQL statements in comments for a given type
func extractSQLComments(pkg *packages.Package, typeName string) []string {
	var sqlStatements []string
	// Find the struct in the AST
	for _, file := range pkg.Syntax {
		for _, decl := range file.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok {
				continue
			}

			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok || typeSpec.Name.Name != typeName {
					continue
				}

				structType, ok := typeSpec.Type.(*ast.StructType)
				if !ok || structType.Fields == nil {
					continue
				}

				// Look for SQL comments in the struct fields
				// Check for comments in the struct's closing area (usually stored in the Incomplete field)
				// Since Go's AST doesn't directly expose trailing comments inside structs,
				// we need to look through all comments in the file
				for _, commentGroup := range file.Comments {
					for _, comment := range commentGroup.List {
						if comment.Pos() >= structType.Pos() && comment.End() <= structType.End() {
							if sql, ok := strings.CutPrefix(strings.TrimSpace(comment.Text), "//sqlgen:"); ok {
								sql = strings.TrimSpace(sql)
								// Check if this comment is within the struct's position range
								sqlStatements = append(sqlStatements, sql)
							}
						}
					}
				}
			}
		}
	}

	return sqlStatements
}
